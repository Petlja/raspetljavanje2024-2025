Mutable и imutable типови података
::::::::::::::::::::::::::::::::::

У Pythonu, типови података могу бити подељени на mutable (променљиви) и immutable (непроменљиви). Ово се односи на то да ли се вредност објекта може мењати након што је креиран.

Референца на објекат
--------------------

**Класа** је шаблон за тип податка. Сваки тип податка у Pythonu је класа.

**Објекат** је инстанца класе. Ако је int класа, неки број је објекат те класе. Могуће је креирати више објеката од исте класе. Сваки објекат има своју меморијску локацију. 

Могуће је креирати `custom` класе али то није покривено овим курсом.

Сви подаци у Pythonu се чувају као објекти. Променљива је референца на објекат. Када се променљива проследи функцији, прослеђује се референца на објекат, а не сам објекат. 
Ако се објекат проследи функцији, прослеђује се референца на објекат, а не копија објекта. 

Референца се може замислити као ознака места у меморији где се налази податак. Када функцији проследимо променлјиву ми прослеђујемо референцу на место у меморији где се налази податак а не цео податак (који заузима много више простора).


Immutable типови података
-------------------------

Immutable типови података су типови података који не могу бити мењани након што су креирани. 
Када је формирана променљива непроменљивог типа она добија своју референцу на меморијску локацију где се налази објекат. 
Када се промени вредност променљиве, мења се вредност објекта на меморији али се мења и адреса (референца на меморијску локацију). 
У ствари се креира нови објекат на новој меморијској локацији, а променлјива менја своју референцу да референцира нову локацију.

- int
- float
- str
- tuple

.. activecode:: 9_2_primer_2
    :coach:

    x = 5
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x += 1
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))

Можемо приметити да се адреса променила, што значи да је креиран нови објекат на новој меморијској локацији.


Mutable типови података
------------------------

Mutable типови података су типови података који могу бити мењани након што су креирани. Када је формирана променлјива променлјивог типа она добија своју референцу на меморијску локацију где се налази објекат. 
Када се промени вредност променљиве, мења се вредност објекта на меморији али се не мења адреса (референца на меморијску локацију).

- list
- dict
- set

.. activecode:: 9_2_primer_1
    :coach:

    x = [1, 2, 3]
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x[0] = 4
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))

Можемо приметити да се адреса није променила, што значи да је податак на датој меморијској локацији промењена. 


Проблеми са mutable типовима података
-------------------------------------

Проблеми са mutable типовима података се јављају када се проследи променљива функцији и ако се унутар функције промени вредност променљиве.

.. activecode:: 9_2_primer_3
    :coach:

    def promeni(lista):
        lista[0] = 5

    x = [1, 2, 3]
    print("Promenljiva x ima vrednost", x)
    promeni(x)
    print("Promenljiva x ima vrednost", x)

Приметимо да се вредност променила иако нисмо мењали променљиву у главном делу програма. Ово се дешава зато што се функцији прослеђује референца на мем. локацију. 
Када функција измени локалну променлјиву она менја податак на истој мем. локацији на коју показује променлјива у гланом делу кода. 

Овај проблем се не јавлја са непроменлјивим типовима података зато што када се локалној променлјивој додели нова вредност та вредност се поставлја на нову мем. локацију, 
а локална променлјива добија нову референцу на нову мем. локацију.

.. activecode:: 9_2_primer_4
    :coach:

    def promeni(x):
        x = 5

    x = 3
    print("Promenljiva x ima vrednost", x)
    promeni(x)
    print("Promenljiva x ima vrednost", x)

Слочан проблем се може десити када се вредност листе додељује новој променљивој.

.. activecode:: 9_2_primer_5
    :coach:

    x = [1, 2, 3]
    y = x
    y[0] = 5
    print("Promenljiva x ima vrednost", x)

Променљива `y` добија референцу на исту мем. локацију као и `x`. Када се промени вредност `y` мења се и вредност `x`.

Да бисмо избегли ово може се користити метода `copy()`.

.. activecode:: 9_2_primer_6
    :coach:

    x = [1, 2, 3]
    y = x.copy()
    y[0] = 5
    print("Promenljiva x ima vrednost", x)

Сада се вредност `x` не мења зато што функција `copy()` креира нови објекат на новој мем. локацији и прослеђује референцу на нову локацију.
