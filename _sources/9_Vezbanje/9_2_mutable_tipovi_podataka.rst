Mutable и immutable типови података
::::::::::::::::::::::::::::::::::

У Пајтону, типови података могу бити подељени на mutable (променљиви) и immutable (непроменљиви). Ово се односи на то да ли се вредност објекта може мењати након што је креиран.

Референца на објекат
--------------------

**Класа** је шаблон за тип податка. Сваки тип податка у Пајтону је класа.

**Објекат** је инстанца класе. Ако је int класа, неки број је објекат те класе. Могуће је креирати више објеката исте класе. Сваки објекат има своју меморијску локацију. 

Могуће је креирати `custom` класе, али то није покривено овим курсом.

Сви подаци у Пајтону чувају се као објекти. Променљива је референца на објекат. Када се променљива проследи функцији, прослеђује се референца на објекат, а не сâм објекат. 
Ако се објекат проследи функцији, прослеђује се референца на објекат, а не копија објекта. 

Референца се може замислити као ознака места у меморији где се налази податак. Када функцији проследимо променљиву, ми прослеђујемо референцу на место у меморији где се налази податак, а не цео податак (који заузима много више простора).


Immutable типови података
-------------------------

Immutable типови података су типови података који не могу бити мењани након што су креирани. 
Када је формирана променљива непроменљивог типа, она добија своју референцу на меморијску локацију где се налази објекат. 
Када се промени вредност променљиве, мења се вредност објекта на меморији, али се мења и адреса (референца на меморијску локацију). 
У ствари се креира нови објекат на новој меморијској локацији, а променљива мења своју референцу да референцира нову локацију.

- int
- float
- str
- tuple

.. activecode:: 9_2_primer_2
    :coach:

    x = 5
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x += 1
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))

Можемо приметити да се адреса променила, што значи да је креиран нови објекат на новој меморијској локацији.


Mutable типови података
------------------------

Mutable типови података су типови података који могу бити мењани након што су креирани. Када је формирана променљива променљивог типа она добија своју референцу на меморијску локацију где се налази објекат. 
Када се промени вредност променљиве, мења се вредност објекта на меморији, али се не мења адреса (референца на меморијску локацију).

- list
- dict
- set

.. activecode:: 9_2_primer_1
    :coach:

    x = [1, 2, 3]
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x[0] = 4
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))

Можемо приметити да се адреса није променила, што значи да је податак на датој меморијској локацији промењен. 

.. activecode:: 9_2_primer_1
    :coach:

    x = [1, 2, 3]
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x += [4]
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))
    x = x + [4]
    print("Promenljiva x ima vrednost", x, "i adresu", id(x))

Можемо приметити да се у првој измени мем. локација није променила, али се у другој измени мем. локација мења, зато што је у првој измени измењена променљива, док је у другој креиран нови објекат.


Проблеми са mutable типовима података
-------------------------------------

Проблеми са mutable типовима података се јављају када се проследи променљива функцији и ако се унутар функције промени вредност променљиве.

.. activecode:: 9_2_primer_3
    :coach:

    def promeni(lista):
        lista[0] = 5

    x = [1, 2, 3]
    print("Promenljiva x ima vrednost", x)
    promeni(x)
    print("Promenljiva x ima vrednost", x)

Приметимо да се вредност променила иако нисмо мењали променљиву у главном делу програма. Ово се дешава зато што се функцији прослеђује референца на мем. локацију. 
Када функција измени локалну променљиву, она мења податак на истој мем. локацији на коју показује променљива у главном делу кода. 

Овај проблем се не јавља са непроменљивим типовима података зато што, када се локалној променљивој додели нова вредност, та вредност се поставља на нову мем. локацију, 
а локална променљива добија нову референцу на нову мем. локацију.

.. activecode:: 9_2_primer_4
    :coach:

    def promeni(x):
        x = 5

    x = 3
    print("Promenljiva x ima vrednost", x)
    promeni(x)
    print("Promenljiva x ima vrednost", x)

Сличан проблем се може десити када се вредност листе додељује новој променљивој.

.. activecode:: 9_2_primer_5
    :coach:

    x = [1, 2, 3]
    y = x
    y[0] = 5
    print("Promenljiva x ima vrednost", x)

Променљива `y` добија референцу на исту мем. локацију као и `x`. Када се промени вредност `y`, мења се и вредност `x`.

Да бисмо ово избегли, може се користити метода `copy()`.

.. activecode:: 9_2_primer_6
    :coach:

    x = [1, 2, 3]
    y = x.copy()
    y[0] = 5
    print("Promenljiva x ima vrednost", x)

Сада се вредност `x` не мења зато што функција `copy()` креира нови објекат на новој мем. локацији и прослеђује референцу на нову локацију.
